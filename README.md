# FAQC-light-TS

**Fast-Acting Quality Context — TypeScript lightweight framework**  
*(速効品質コンテキスト TS軽量版)*

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](./LICENSE)
[![Docs: JP](https://img.shields.io/badge/Docs-JP-brightgreen)](#)
[![Docs: EN](https://img.shields.io/badge/Docs-EN-lightgrey)](README.en.md)

日本語 | English: [README.en.md](README.en.md)

---

## 目次

- [概要](#概要)
- [なぜ FAQC-light-TS を使うのか](#なぜ-faqc-light-ts-を使うのか)
- [前提条件](#前提条件)
- [この README の使い方](#この-readme-の使い方)
- [クイックスタート](#クイックスタート)
- [npm scripts 一覧](#npm-scripts-一覧)
- [プロジェクト構造](#プロジェクト構造)
- [基本的な開発フロー](#基本的な開発フロー)
- [品質管理のプロンプト](#品質管理のプロンプト)
- [よくある開発シナリオ](#よくある開発シナリオ)
- [品質ポリシーについて](#品質ポリシーについて)
- [トラブルシューティング](#トラブルシューティング)
- [高度な使い方](#高度な使い方)
- [プロンプトのベストプラクティス](#プロンプトのベストプラクティス)
- [チャット分割とハンドオフの実践](#チャット分割とハンドオフの実践)
- [ライセンス](#ライセンス)

---

## 概要

FAQC-light-TS は、AI コーデベロッパ（LLM）と協働して**品質駆動開発**を実現する TypeScript プロジェクトフレームワークです。設計から実装まで一貫した品質基準を維持し、コード生成前に品質コンテキストを把握することで、手戻りコストを最小化します。

### 主要な特徴

- **品質ゲートの自動実行**: ESLint、TypeScript 型検査、ポリシー検証、テストを AI が自動実行
- **品質コンテキストの可視化**: AI が品質ルールを理解し、詳細レポートを自動生成
- **厳格なポリシー検証**: Anti-MVP、型安全性、ドキュメント規約などを事前チェック
- **SPEC-and-DESIGN 駆動**: 仕様を明文化してから実装に移行する明確なフロー
- **プロンプトベース開発**: 自然言語の指示で品質を保ちながら開発を進行

### なぜ FAQC-light-TS を使うのか

#### 品質ゲートだけの場合と比較して

従来の品質ゲート（ESLint + TypeScript + テスト）だけの運用では：

❌ **問題点:**
- AI がコードを生成**した後**にエラーが判明（事後検出）
- エラーの理由や背景が不明確で、修正に複数回の試行が必要
- 品質ルールの意図が共有されず、同じミスを繰り返す
- トークン消費：生成 → エラー → 修正 → エラー → 修正... のループ

✅ **FAQC-light-TS のメリット:**
- **事前理解（pre-read）**: AI がコード生成**前**に品質ルールを理解
- **初回通過率の向上**: 品質コンテキスト（Why/What/How）により適切なコードを初回で生成
- **修正の高速化**: エラー発生時も context.md の「失敗パターン」「LLM典型NGパターン」を参照して的確に修正
- **トークン効率**: 手戻りサイクルを削減し、生成コストを最小化

> 💡 **なぜコンテキストが重要なのか**
>
> LLM は本質的に「ルール」よりも「コンテキスト」を中心に動作します。
>
> - **ルールだけ**（例：「`any` 型を使うな」）の場合：
>   - LLM は表面的に従うだけで、状況判断ができない
>   - 「なぜダメなのか」が分からないため、類似パターンで同じミスを繰り返す
>   - エラー発生時に「どう修正すべきか」の判断基準がない
>
> - **コンテキスト付き**（例：「`any` 型は型安全性を崩壊させ、ランタイムエラーのリスクを高める。代わりに `unknown` を使い型ガードで段階的に絞り込む」）の場合：
>   - LLM はルールの**意図**と**影響**を理解する
>   - 似た状況で適切な判断ができる（応用が効く）
>   - エラー時も「なぜ違反なのか」「どう直すべきか」が明確
>
> これは人間の学習と同じです。「暗記したルール」よりも「原理を理解した知識」の方が、柔軟で適切な判断につながります。
>
> FAQC-light-TS の context.md（Why/Where/What/How）は、LLM がルールを**理解**し、**応用**できるように設計されています。

#### 品質コンテキストだけの場合と比較して

品質コンテキスト（ドキュメントやガイドライン）だけの運用では：

❌ **問題点:**
- ドキュメントと実際の設定（ESLint/TSConfig）の乖離が発生しやすい
- AI がドキュメントを「解釈」するだけで、実際の検証がない
- 品質基準の変更時にドキュメント更新を忘れる
- 実行可能な品質保証が無い

✅ **FAQC-light-TS のメリット:**
- **単一情報源（SoT）**: `qualities/**` の設定ファイルが唯一の真実
- **自動同期**: PRE-COMMON により設定から詳細レポート（context.md）を自動生成
- **実行可能**: 品質ゲートで実際に検証し、違反を検出
- **整合性保証**: 設定変更時は必ず PRE-COMMON を実行し、コンテキストを更新

#### 統合されたフレームワークの価値

FAQC-light-TS は以下を統合します：

1. **規範的設定**（`qualities/**`）: 実行可能な品質ルール
2. **詳細レポート**（`vibecoding/var/contexts/**`）: AI が理解できる形式の品質コンテキスト
3. **実行フロー**（プレイブック）: 設計 → 実装のフェーズ管理
4. **自動検証**（品質ゲート）: 生成コードの品質保証

これにより、「AI が品質を理解して生成 → 自動検証 → 知見を蓄積」のサイクルが回ります。

### トレードオフとコスト

#### デメリット

✋ **初期セットアップコスト:**
- 品質コンテキストの初回生成に時間とトークンを消費
- context.md は1ユニットあたり60-100行の詳細レポート作成が必要
- PRE-COMMON の実行には対象ユニット数 × 生成コスト がかかる

✋ **学習コスト:**
- vibecoding フレームワークの概念（SnD、PRE-COMMON、フェーズ管理）の理解が必要
- `.cursorrules` の設定を読み解く必要がある（Cursor 以外の環境）

✋ **運用コスト:**
- 品質ルール変更時は PRE-COMMON の再実行が必要
- SnD の作成と Ready 判定に時間がかかる（大規模機能の場合）

#### いつ採用すべきか

✅ **推奨するケース:**
- AI エージェントとの協働開発を本格的に行う
- 品質基準を明確に定義し、一貫性を保ちたい
- 複数人（または複数 AI セッション）で品質基準を共有したい
- トークンコストよりも成果品質と手戻り削減を優先したい
- 中長期的に保守するプロジェクト

❌ **不向きなケース:**
- 使い捨てスクリプトやプロトタイプ
- 1回限りの小規模タスク（品質コンテキスト生成コストが見合わない）
- 品質基準が流動的で頻繁に変わる初期探索フェーズ

---

## 前提条件

### 必須環境

- **Node.js**: 18 LTS 以上（推奨: 現行LTS）
- **npm**: Node.js に同梱されているもの
- **Cursor IDE**: このフレームワークは Cursor の AI エージェント機能を前提に設計されています

### Cursor 向けの設計

このプロジェクトは `.cursorrules` ファイルにより、Cursor の AI エージェントが以下を自動的に行うよう設定されています：

- 品質ゲートコンテキストの理解と参照
- SPEC-and-DESIGN（SnD）駆動開発フローの遵守
- プレイブック（PRE-COMMON、PRE-SnD、PRE-IMPL）の自動実行
- 品質ゲート失敗時の自動診断と修正提案
- コメント・ドキュメントの規約準拠

### Cursor 以外の環境で使用する場合

他の AI エージェント環境（GitHub Copilot、その他の LLM ツール）で使用する場合：

1. **`.cursorrules` の内容を環境に合わせて変換**
   - `.cursorrules` はプロジェクト全体の設計方針とワークフローを定義しています
   - 使用する AI ツールの設定ファイル形式に変換してください
   - 特に重要な設定：
     - `paths` セクション（ディレクトリ構造）
     - `quality_gate` セクション（品質ゲート自動実行）
     - `agent_phase` セクション（フェーズ切り替えルール）
     - `guardrails` セクション（実装前の安全策）

2. **プレイブックの手動参照**
   - `vibecoding/docs/PLAYBOOK/` 配下のドキュメントを明示的に参照するよう指示が必要
   - Cursor では自動参照されますが、他環境では手動でプロンプトに含める必要がある可能性があります

3. **品質コンテキストの明示的な読み込み**
   - `vibecoding/var/contexts/qualities/**/context.md` を生成後、明示的に参照するよう指示
   - Cursor では PRE-COMMON 実行時に自動参照されますが、他環境では手動指示が必要な可能性があります

4. **フェーズ管理の手動化**
   - 「設計フェーズ」→「実装フェーズ」の切り替えを明示的に指示
   - `PHASE=IMPL 承認: SnD=<path>` などのトリガーフレーズを使用することが必要な可能性があります

### 推奨環境

このリポジトリをそのまま使用する場合は、**Cursor IDE** の使用を強く推奨します。`.cursorrules` による自動化により、品質駆動開発のフローがシームレスに実行されます。

---

## この README の使い方

このドキュメントは、**あなた（ユーザー）が AI エージェント（LLM）にどのような指示を出せば良いか**を説明するガイドです。各セクションには「プロンプト例」が記載されており、そのままコピー&ペーストして使用できます。

### ⚠️ 重要: LLM の確率的な性質について

この README に記載されている「AI の動作」は、`.cursorrules` とプレイブックに基づいた**期待される動作パターン**です。しかし、LLM（大規模言語モデル）は確率的なシステムであるため、常に記載通りの動作を保証するものではありません。以下の点にご注意ください：

- AI が期待と異なる動作をする場合があります
- プロンプトの解釈が意図と異なる可能性があります
- 同じプロンプトでも、コンテキストやモデルの状態により異なる結果になることがあります

期待通りの動作にならない場合は、プロンプトを具体的に言い換える、段階を細かく分ける、または `.cursorrules` の該当セクションを明示的に参照するよう指示することで改善できる場合があります。

### 📄 この README と AI の関係

**重要**: この README.md は **ユーザー向けドキュメント** であり、AI エージェントが直接参照すべき技術仕様ではありません。

- **AI が参照すべきもの**: `.cursorrules`, `vibecoding/docs/PLAYBOOK/`, `qualities/**`, `vibecoding/var/contexts/qualities/**`
- **ユーザーが読むもの**: この `README.md`（プロンプトの書き方やフレームワークの説明）

このリポジトリには `.cursorignore` が設定されており、`README.md` は AI のコンテキストから除外されています。これにより：

- プロンプト例を AI が「自分への指示」と誤解するリスクを回避
- 「AI の動作」という記述が AI 自身を混乱させることを防止
- コンテキストウィンドウを節約し、品質ゲート関連の情報に集中

AI と対話する際、慣れないうちはこの README のプロンプト例をコピー&ペーストして自分の目的に応じて利用してください。AI は `.cursorrules` とプレイブックに従って動作します。

補足: 試験的に README を一時的に AI のコンテキストに含めたい場合は、`.cursorignore` を編集して対象から外してください。

---

## クイックスタート

### 初回セットアップ

**プロンプト例:**
```
このプロジェクトの初回セットアップを実行してください。
依存関係のインストールと品質コンテキストの初期化を行ってください。
```

AI は以下を実行します:
- `npm install` で依存関係をインストール
- `npm run check:pre-common` で品質コンテキストを生成
- 品質ゲートの初回実行で環境を確認

手動で実行する場合（Cursor 以外の環境など）:

```bash
npm install
npm run check:pre-common
npm run check
```

---

## npm scripts 一覧

| スクリプト | 説明 |
|---|---|
| `npm run check` | 統一品質ゲート実行（ポリシー検証・型検査・Lint・テスト） |
| `npm run check:fast` | 品質ゲートの高速版（範囲を一部短縮） |
| `npm run check:pre-common` | PRE-COMMON 実行。品質コンテキスト詳細レポート作成/更新 |
| `npm run typecheck` | TypeScript 型検査（`qualities/tsconfig` を使用） |
| `npm run lint` | ESLint 実行（`qualities/eslint` を SoT として使用） |
| `npm run test` | テスト実行（vitest） |
| `npm run verify:policy` | 重要ポリシーの個別検証（Anti-MVP, no_relaxation） |

---

## プロジェクト構造

```
FAQC-light-TS/
├── qualities/                  # 品質ゲート設定（単一情報源）
│   ├── check-steps.ts         # ゲート実行順序の定義
│   ├── eslint/                # ESLint設定（5つのユニット）
│   │   ├── 01-module-boundaries/     # モジュール境界検証
│   │   ├── 02-type-safety/           # 型安全性検証
│   │   ├── 03-documentation/         # ドキュメント規約
│   │   ├── 04-complexity-and-magic/  # 複雑度とマジックナンバー
│   │   ├── 05-environment-exceptions/ # 環境変数例外検証
│   │   └── plugins/                  # カスタムESLintプラグイン
│   ├── tsconfig/              # TypeScript厳密設定
│   └── policy/                # カスタムポリシー検証
│       ├── anti_mvp/          # 互換残骸・沈黙フォールバック禁止
│       ├── jsdoc_no_duplicate/ # JSDoc重複禁止
│       ├── no_relaxation/     # 型緩和禁止
│       └── no_unknown_double_cast/ # 不明なダブルキャスト禁止
│
├── vibecoding/                # 開発フレームワーク
│   ├── docs/PLAYBOOK/         # プレイブック（AI が参照）
│   │   ├── PRE-COMMON.md      # 品質コンテキスト更新手順
│   │   ├── PRE-SnD.md         # SPEC-and-DESIGN作成前手順
│   │   └── PRE-IMPL.md        # 実装開始前手順
│   ├── scripts/qualities/     # 品質管理スクリプト
│   └── var/
│       ├── contexts/qualities/  # 品質コンテキスト詳細レポート（AI生成）
│       └── SPEC-and-DESIGN/     # 仕様設計ドキュメント
│
├── scripts/qualities/         # 実行スクリプト
│   └── check.ts               # 統一品質ゲート実行ポイント
│
└── tests/                     # テスト
    └── quality/               # 品質検証テスト
```

---

## 基本的な開発フロー

### 1. 新機能の開発を始める

**プロンプト例:**
```
新しい機能「[機能名]」を開発したいです。
この機能は[簡単な説明]を行うものです。
SPEC-and-DESIGN を作成してください。
```

AI の動作:
1. `PRE-COMMON` を実行して品質コンテキストを最新化
2. `vibecoding/docs/PLAYBOOK/_SnD-template.md` をベースに SnD を作成
3. 背景、目的、非目標、設計構想、品質ゲート、受入条件などを記述
4. 不明点があれば「未確定事項」として明示し、あなたに質問

### 2. 仕様を確定する

**プロンプト例:**
```
SnD の未確定事項について、[あなたの回答や補足情報]。
SnD を更新して Ready 状態にしてください。
```

AI の動作:
1. 未確定事項を解消し、SnD を更新
2. `quality_refresh_hash_at_created` を記録
3. SnD の `status` を `Ready` に変更
4. 実装フェーズへの移行準備が完了

### 3. 実装を開始する

**プロンプト例:**
```
PHASE=IMPL 承認: SnD=vibecoding/var/SPEC-and-DESIGN/SnD-[日付]-[名前].md
```

または、より自然な表現:
```
[機能名] の実装を開始してください。
SnD に基づいてコードを生成してください。
```

AI の動作:
1. `PRE-IMPL` を実行して実装前の品質ゲートを確認
2. `quality_refresh_hash_before_impl` を記録
3. SnD の内容に基づいてコードとテストを生成
4. 生成後、品質ゲートを自動実行
5. エラーがあれば詳細を報告し、修正方法を提案

### 4. 既存コードの修正

**プロンプト例:**
```
[ファイル名] の [機能/関数] を修正してください。
[修正内容の説明]
```

AI の動作:
1. 既存の SnD があれば参照、なければ小規模修正として処理
2. 修正範囲が小さい場合（`MAINT=承認` の範囲内）はそのまま実行
3. 修正範囲が大きい場合は SnD の作成を提案

---

## 品質管理のプロンプト

### 品質ゲートを実行する

**プロンプト例:**
```
品質ゲートを実行してください。
```

または
```
コードの品質チェックを実行してください。
```

AI の動作:
- ポリシー検証、型検査、Lint、テストを順次実行
- エラーがあれば詳細を報告し、修正方法を提案

### 品質コンテキストを更新する

**プロンプト例:**
```
品質コンテキストを更新してください。
```

または
```
PRE-COMMON を実行してください。
```

AI の動作:
1. `npm run check:pre-common` を実行
2. 不足している品質コンテキストがあれば自動生成
3. `vibecoding/var/contexts/qualities/**/context.md` を更新（60-100行の詳細レポート）
4. 各ユニットの Why/Where/What/How を明確化

### 特定の品質ゲートのみを実行する

**プロンプト例:**
```
型検査だけを実行してください。
```

または
```
ESLint だけを実行してください。
```

または
```
Anti-MVP ポリシーだけを確認してください。
```

---

## よくある開発シナリオ

### シナリオ 1: 新しいユーティリティ関数を追加したい

**プロンプト例:**
```
src/utils/ に [関数名] という新しいユーティリティ関数を追加したいです。
この関数は [説明] を行います。
SnD を作成して実装してください。
```

### シナリオ 2: バグを修正したい

**プロンプト例:**
```
[ファイル名] の [関数名] にバグがあります。
[バグの説明]
修正してください。
```

小規模な修正の場合、AI は SnD を作成せずに直接修正することがあります。

### シナリオ 3: コードレビューをしてほしい

**プロンプト例:**
```
[ファイル名] のコードをレビューしてください。
品質ゲートの観点で改善点を教えてください。
```

AI の動作:
- 品質コンテキストに基づいてコードを分析
- Anti-MVP ポリシー、型安全性、ドキュメント規約などの観点から指摘
- 具体的な改善案を提示

### シナリオ 4: テストを追加したい

**プロンプト例:**
```
[ファイル名] のテストを追加してください。
[テストしたい内容]
```

### シナリオ 5: 品質ゲートでエラーが出た

品質ゲートは AI が自動実行しますが、手動で確認したい場合:

**プロンプト例:**
```
最後の品質ゲートの結果を詳しく教えてください。
```

または
```
[エラーメッセージ] というエラーが出ています。
どう修正すればいいですか？
```

---

## 品質ポリシーについて

### Anti-MVP ポリシー（重要）

このプロジェクトでは、以下を**厳格に禁止**しています:

❌ **禁止事項:**
- 沈黙フォールバック（エラーを握り潰す）
- 後方互換のための残留実装（使われていないコードの温存）
- TODO/FIXME にチケット番号がない
- 段階的移行（新旧実装の長期併存）
- 例外駆動制御（try/catch を正常系の分岐に使う）

✅ **推奨パターン:**
- 明示的なエラーハンドリング（`throw new Error()` または `Result/Either` 型）
- 型安全な列挙（`assertNever()` で網羅性を保証）
- 明示的な機能フラグ（期限・削除期日・チケット番号を明記）

AI はこれらのポリシーを常に遵守してコードを生成します。

### コメント規約

すべての `src/**/*.ts` ファイルには、以下の構造を持つ先頭ヘッダが必要です:

```typescript
/**
 * @file ファイルの目的（1行）
 * 備考: 特記事項なし（または具体的な備考）
 * - 箇条書き1（設計原則や品質要件を8-10行で記述）
 * - 箇条書き2
 * - ...（合計8-10行）
 * @see 関連ドキュメント1（最低2件必須）
 * @see 関連ドキュメント2
 * @snd 関連するSPEC-and-DESIGNへのパス（または「なし」）
 */
```

AI は自動的にこの形式でコメントを生成します。日本語で記述されます。

---

## トラブルシューティング

### 品質ゲートが失敗する場合

**プロンプト例:**
```
品質ゲートが失敗した理由を詳しく教えてください。
どう修正すればいいですか？
```

AI の動作:
1. エラーメッセージを分析
2. 該当する品質コンテキスト（`context.md`）を参照
3. 「失敗パターン」や「LLM典型NGパターン」と照合
4. 具体的な修正方法を提案し、必要に応じて自動修正

### SnD が Ready にならない場合

**プロンプト例:**
```
SnD を Ready 状態にするために、何が不足していますか？
```

AI の動作:
1. 「未確定事項」セクションをチェック
2. 不足している情報を質問
3. 必要な情報が揃えば Ready に更新

### AI が勝手に実装を始めてしまう場合

このプロジェクトでは、AI は以下の条件を**すべて満たすまで**実装を開始しません:

1. SnD が存在し、`status: Ready` である
2. `quality_refresh_hash_at_created` が記録されている
3. `quality_refresh_hash_before_impl` が記録されている
4. あなたが明示的に実装開始を承認している（`PHASE=IMPL 承認` フレーズ）

小規模な修正（テストの追加、数行の変更）の場合のみ、`MAINT=承認` の範囲で例外的に実行されます。

---

## 高度な使い方

### 新しい品質ゲートを追加する

**プロンプト例:**
```
新しいポリシー「[ポリシー名]」を追加したいです。
このポリシーは [説明] をチェックするものです。
設定ファイルとスクリプトを作成してください。
```

AI の動作:
1. SnD を作成して設計を明確化
2. `qualities/policy/[ポリシー名]/` に設定ファイルを作成
3. `qualities/check-steps.ts` に定義を追加
4. 品質コンテキストを自動生成

### プロジェクト全体のリファクタリング

**プロンプト例:**
```
[リファクタリングの内容] を行いたいです。
影響範囲を分析して、SnD を作成してください。
```

AI の動作:
1. 影響範囲を静的解析
2. 包括的な SnD を作成（依存関係、移行計画、ロールバック手順を含む）
3. あなたの承認を得てから段階的に実装

### 品質基準のカスタマイズ

**プロンプト例:**
```
[特定のルール] を緩和/厳格化したいです。
理由は [説明] です。
```

AI の動作:
1. 影響範囲を分析
2. SnD を作成して変更の妥当性を検証
3. `qualities/` 配下の設定を更新
4. 品質コンテキストを再生成

---

## プロンプトのベストプラクティス

### ✅ 良いプロンプト

- **具体的**: 「○○機能を追加」「○○ファイルの○○関数を修正」
- **理由を含む**: 「○○のため、○○が必要です」
- **段階的**: 大きなタスクは「まず設計」→「実装」と分ける

例:
```
ユーザー認証機能を追加したいです。
JWT トークンを使った認証で、ログイン・ログアウト・トークン検証が必要です。
まず SnD を作成してください。
```

### ❌ 避けるべきプロンプト

- **曖昧**: 「何か改善して」「もっと良くして」
- **複数の要求を一度に**: 「A と B と C を全部やって」（段階的に依頼する）
- **品質基準を無視**: 「とりあえず動けばいいので」（品質ゲートは必須）

### プロンプト例（ブロック崩しゲーム）

```
TypeScript で昔ながらのブロック崩しを作りたいです。まず SPEC-and-DESIGN（SnD）を作成し、未確定事項を質問のうえ Ready にしてから実装してください。Anti-MVP/型安全/ドキュメント規約に準拠し、品質ゲート（check/typecheck/lint/test）が緑になること。要件は次の通りです。
- 増殖ブロック: 破壊時にボールを同位置で増殖し、増殖ボールの角度は元と必ず異なる（完全一致はNG）
- マージン: ブロックと左右壁は0、上壁と最上段ブロックの間はブロック2個分
- 効果音: 反射/破壊/増殖/クリア/ゲームオーバー
- ステージ: 1ステージ。全破壊で派手なエンディング表示し、クリックで初期状態から再開。その際ボール速度はアップ
- 残機: 初期2、ゲームオーバー後も2にリセット。残機0でゲームオーバー画面（派手な演出＋効果音）。ゲームオーバーでボール速度はリセット
- 配置: ブロックはランダム配置で密度約80%。増殖ブロックは全体の約30%で盤面上側に寄せる
- ボール: 初期発射は真上。パドル反射は基本「入射角=反射角」だが、ヒット位置やパドルの運動状態で角度を変化
- 角度制約: 水平基準で±20度以内のほぼ水平な弾道は禁止（常に±20度超になるようクランプ）
- 入力: マウスのみでも、キーボードのみでも全操作が完結（移動・発射・画面遷移）
- 受入条件: 上記仕様が全て視覚・聴覚的に確認でき、再開時の速度アップ/ゲームオーバー時の速度リセット/残機初期化が成立

SnD が Ready になったら、PHASE=IMPL 承認フローに従って実装に進んでください。
```

注記:
- 本フレームワーク開発側ではこのプロンプトを利用して動作確認しています。
- 動作確認対象 LLM モデルは、gpt-5 / gpt-5-high / Sonnet4.5 です。
- 実装完了時点では成果物に不具合が含まれる場合もあり、それは別途追加の「会話」で修正しています。
- SnD 作成から実装完了、修正完了までに、モデルにもよりますが 1,000万トークン前後を必要とします。

---

## AI との協働のコツ

- 必ずユーザー側で巻き戻しが可能なようにこまめなコミットや保存を忘れない。

1. **設計を急がない**: AI は SnD の作成を重視します。不明点があれば質問してください。
2. **品質ゲートを信頼する**: AI は自動的に品質チェックを行います。エラーは学習の機会です。
3. **段階的に進める**: 大きな機能は小さな SnD に分割して開発します。
4. **フィードバックを与える**: 生成されたコードに不満があれば、具体的に指摘してください。

- 品質ゲートに関する質問や、品質ゲートの追加・削除も AI に相談してよい。
  - プロンプト例:
    ```
    品質ゲートの構成を見直したいです。現状のチェック順序と目的を説明し、改善提案をください。
    ```
    ```
    Anti-MVP に加えて [新ポリシー名] を追加したいです。影響範囲を分析して、SnD を作成してから実装してください。
    ```
    ```
    一時的に [ルール名] を緩和/削除したい理由があります。妥当性の検証とリスク、代替策を提示してください。
    ```

- `.cursorrules` やプレイブックに関する質問・変更も AI に相談してよい。
  - プロンプト例:
    ```
    .cursorrules の agent_phase と guardrails の関係を説明してください。安全性を落とさずに、英語トリガーの追加方法を提案してください。
    ```
    ```
    PRE-IMPL の手順をカスタマイズしたいです。現在の手順を要約し、変更案の SnD と受入条件を作成してください。
    ```
    ```
    プレイブック（PRE-COMMON/PRE-SnD/PRE-IMPL）の役割分担を比較し、私のワークフローに最適化した運用例を示してください。
    ```

---

## チャット分割とハンドオフの実践

- **狙い**: 証跡・再現性を担保し、スコープ分離とコンテキスト節約を図り、SnD 単位で PRE-IMPL→IMPL→品質ゲートを回しやすくする。
- **実践ポイント**:
  - 残タスクや修正は SnD に切り出し、別チャットで実施する。
  - 後続モデル向けに、自己完結のハンドオフ .md を `vibecoding/var/SPEC-and-DESIGN/handoff-<slug>.md` に出力させる。
  - スレッドは「SnD Ready→IMPL 直前」「大きな仕様変更」「スレが長大化し始めた時」に分割する。
  - SnD 更新・フェーズ切替・品質ゲート通過ごとにコミット/保存して巻き戻し可能性を維持する。

**プロンプト例**

- 残タスクの切り出し
  ```
  残タスクを新しい SnD に切り出して vibecoding/var/SPEC-and-DESIGN/SnD-<YYYYMMDD>-<slug>.md に自己完結でまとめてください。未確定事項・受入条件・次アクションも含めて。
  ```

- 後続モデルへのハンドオフ
  ```
  後続モデルがこの続きから実装できるよう、vibecoding/var/SPEC-and-DESIGN/handoff-<slug>.md に前提・決定・差分・実装方針・受入条件を自己完結で出力してください。
  ```

- フェーズ切替（承認）
  ```
  SnD が Ready なら PHASE=IMPL 承認: SnD=<path> で実装へ移行してください。（英語: PHASE=IMPL APPROVE: SnD=<path>）
  ```

---

## ライセンス

MIT License

Copyright (c) 2025 cozyupk

詳細は [LICENSE](./LICENSE) を参照してください。

---

## さらに詳しく知りたい場合

- [vibecoding/docs/PLAYBOOK/](vibecoding/docs/PLAYBOOK/) - AI が参照するプレイブック
- [qualities/](qualities/) - 品質ゲート設定の詳細
- [qualities/policy/anti_mvp/anti_mvp_policy.md](qualities/policy/anti_mvp/anti_mvp_policy.md) - Anti-MVP ポリシーの全文

---

## プロンプトクイックリファレンス

| やりたいこと | プロンプト例 |
|------------|------------|
| 新機能開発 | `[機能名]を開発したいです。SnD を作成してください` |
| 実装開始 | `PHASE=IMPL 承認: SnD=[パス]` または `[機能名]の実装を開始してください` |
| バグ修正 | `[ファイル名]の[内容]を修正してください` |
| テスト追加 | `[ファイル名]のテストを追加してください` |
| コードレビュー | `[ファイル名]をレビューしてください` |
| 品質ゲート実行 | `品質ゲートを実行してください` |
| 品質コンテキスト更新 | `品質コンテキストを更新してください` |
| エラー解決 | `[エラー]を修正してください` |
| リファクタリング | `[内容]をリファクタリングしたいです。SnD を作成してください` |

---

## Code of Conduct

本プロジェクトは行動規範に従います（後日追加予定）。

## Security

脆弱性のご連絡は Issue ではなく非公開連絡でお願いします: cozyupk2025@gmail.com

---

## 最後に

このリポジトリには、README には明示的に書かれていない設計上の「工夫」や「仕組み」がいくつか織り込まれています。使い込むうちに、ふとした瞬間に「ああ、そういうことか」と気づくことがあるかもしれません。

もしそんな発見があったら、それはこのフレームワークの奥行きを感じていただけた証拠です。ぜひその気づきを大切にしてください。

---

**Happy Coding with AI! 🚀**
